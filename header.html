<!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <title>External Attack Surface Analysis</title>
        <!-- Chart.js for charts -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <style>
          /* Root CSS variables for theme colors and font sizes */
          :root {
            /* Light theme colors */
            --light-bg-color: #f9f9f9;
            --light-text-color: #333;
            --light-header-bg: #fff;
            --light-header-text: #333;
            --light-table-bg: #fff;
            --light-table-header-bg: #eee;
            --light-table-border: #ddd;
            --light-toggle-bg: #757574;
            --light-toggle-btn: #fff;

            /* Dark theme colors */
            --dark-bg-color: #1f1f1f;
            --dark-text-color: #f0f0f0;
            --dark-header-bg: #2a2a2a;
            --dark-header-text: #ffffff;
            --dark-table-bg: #2a2a2a;
            --dark-table-header-bg: #3a3a3a;
            --dark-table-border: #444;
            --dark-toggle-bg: #555;
            --dark-toggle-btn: #ffffff;

            /* Active theme variables (default to light) */
            --bg-color: var(--light-bg-color);
            --text-color: var(--light-text-color);
            --header-bg: var(--light-header-bg);
            --header-text: var(--light-header-text);
            --table-bg: var(--light-table-bg);
            --table-header-bg: var(--light-table-header-bg);
            --table-border: var(--light-table-border);
            --toggle-bg: var(--light-toggle-bg);
            --toggle-btn: var(--light-toggle-btn);

            /* Font sizing variables */
            --font-size-sm: 12px;
            --font-size-base: 13px;
            --font-size-md: 14px;
            --font-size-lg: 16px;
            --heading-font-size: 22px;
          }

          /* Dark theme override */
          body.dark {
            --bg-color: var(--dark-bg-color);
            --text-color: var(--dark-text-color);
            --header-bg: var(--dark-header-bg);
            --header-text: var(--dark-header-text);
            --table-bg: var(--dark-table-bg);
            --table-header-bg: var(--dark-table-header-bg);
            --table-border: var(--dark-table-border);
            --toggle-bg: var(--dark-toggle-bg);
            --toggle-btn: var(--dark-toggle-btn);
          }

          /* Basic styles for body and fonts */
          body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            font-size: var(--font-size-base);
            line-height: 1.4;
          }

          /* HEADER styles */
          .header {
            position: relative;
            background-color: var(--header-bg);
            color: var(--header-text);
            text-align: center; /* centers the heading horizontally */
            padding: 12px 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
          }

          .header h1 {
            margin: 0;
          }

          /* Keep the toggle button on the right */
          .toggle-btn {
            position: absolute;
            right: 20px;
            top: 12px; /* adjust as needed to align vertically */
            background-color: var(--toggle-bg);
            border: none;
            color: var(--toggle-btn);
            cursor: pointer;
            border-radius: 4px;
            font-size: var(--font-size-m);
            transition: background-color 0.2s, color 0.2s;
          }
          /* Keep the toggle button on the right */
          .csv-btn {
            position: absolute;
            right: 20px;
            top: 35px; /* adjust as needed to align vertically */
            background-color: var(--toggle-bg);
            border: none;
            color: var(--toggle-btn);
            cursor: pointer;
            border-radius: 4px;
            font-size: var(--font-size-m);
            transition: background-color 0.5s, color 0.2s;
          }

          .toggle-btn:hover {
            opacity: 0.9;
          }

          /* Top controls for table filters and pagination */
          .table-top-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
          }

          /* Container for the entire report */
          .container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
          }

          /* Scoreboard styles for summary cards */
          .scoreboard {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
          }
          .score-card {
            background-color: var(--table-bg);
            border: 1px solid var(--table-border);
            border-radius: 5px;
            flex: 1 1 200px;
            padding: 10px;
            text-align: center;
          }
          .score-card h2 {
            margin: 0;
            font-size: 1.6em;
            font-weight: 500;
          }
          .score-card p {
            margin: 5px 0 0;
            font-size: var(--font-size-sm);
            color: var(--text-color);
          }

          .hint{
            color: red;
          }
          /* Grid layout for charts */
          .charts-grid {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            margin-bottom: 20px;
          }
          .chart-container {
            position: relative;
            background-color: var(--table-bg);
            border: 1px solid var(--table-border);
            border-radius: 5px;
            padding: 10px;
            box-sizing: border-box;
          }
          .chart-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
          }

          /* Search box styling */
          #searchBox {
            margin: 0;
            padding: 6px 10px;
            width: 250px;
            font-size: var(--font-size-sm);
            border: 1px solid var(--table-border);
            border-radius: 4px;
          }

          /* Table controls styling */
          .table-controls {
            margin: 0;
            display: flex;
            justify-content: flex-end;
            align-items: center;
          }
          .table-controls label {
            margin-right: 6px;
            font-size: var(--font-size-sm);
          }
          .table-controls select {
            font-size: var(--font-size-sm);
            padding: 4px 8px;
            border: 1px solid var(--table-border);
            border-radius: 4px;
            background-color: var(--table-bg);
            color: var(--text-color);
          }

          /* Main table styling */
          table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            background-color: var(--table-bg);
            font-size: var(--font-size-sm);
          }
          th, td {
            border: 1px solid var(--table-border);
            padding: 8px;
            text-align: left;
            vertical-align: top;
            color: inherit;
          }
          th {
            background-color: var(--table-header-bg);
            font-weight: 600;
          }

          /* Filter dropdown styling in table header */
          #filter-row select {
            width: 100%;
            font-size: var(--font-size-sm);
            padding: 2px 4px;
            border: 1px solid var(--table-border);
            border-radius: 3px;
            background-color: var(--table-bg);
            color: var(--text-color);
          }

          /* Pagination controls styling */
          #paginationControls {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
          }
          #paginationControls button {
            padding: 6px 12px;
            cursor: pointer;
            font-size: var(--font-size-sm);
            border-radius: 4px;
            border: 1px solid var(--table-border);
            background-color: var(--toggle-bg);
            color: var(--toggle-btn);
            transition: background-color 0.2s, color 0.2s;
          }
          #paginationControls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
          }

          /* Ensuring proper display for the last header column */
          th:nth-child(33) {
            white-space: nowrap;
          }
        </style>
      </head>
      <body>
        <!-- Header section with title and theme toggle button -->
        <div class="header">
          <h1>External Attack Surface Analysis Report</h1>
          <button id="themeToggle" class="toggle-btn">DARK THEME</button>
          <button id="exportCsvButton" class="csv-btn">EXPORT CSV</button>
        </div>
        <div class="container">
          <!-- Scoreboard section for summary metrics -->
          <div class="scoreboard" id="scoreboard"></div>

          <!-- Grid of charts -->
          <div class="charts-grid">
            <div class="chart-container">
              <canvas id="priorityChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="domainCountChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="colleagueEndpointChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="loginBarChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="statusCodeChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="portChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="serviceChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="techChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="tlsUsageChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="certExpiryChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="headersChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="emailSecChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="cdnChart"></canvas>
            </div>
            <div class="chart-container">
              <canvas id="cdnTypeChart"></canvas>
            </div>
          </div>

          <!-- Controls above the table: search box and rows per page selector -->
          <div class="table-top-controls">
            <input type="text" id="searchBox" placeholder="Filter table (e.g. domain, status code, tech)..." />
            <div class="hint">
            <h4>Mouseover to Risk Score to Evaluate Reasons for Scoring</h2>
            </div>
            <div class="table-controls">
              <label for="rowsPerPageSelect">Rows per page:</label>
              <select id="rowsPerPageSelect">
                <option value="20">20</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">ALL</option>
              </select>
            </div>
          </div>

          <!-- Main report table with dynamic filters in header -->
          <table id="report-table">
            <thead>
              <tr>
                <th id="riskScoreHeader">
                  Attack Surface Score<span id="riskSortToggle" style="cursor:pointer; user-select:none; margin-left:5px;">▼</span>
                </th>
                <th>Domain</th>
                <th>Purpose</th>
                <th>Resolvers</th>
                <th>A Records</th>
                <th>NS Records</th>
                <th>MX Records</th>
                <th>DNS Status</th>
                <th>CDN Name</th>
                <th>CDN Type</th>
                <th>Port</th>
                <th>URL</th>
                <th>Redirect Location</th>
                <th>Homepage Title</th>
                <th>Web Server</th>
                <th>Login Found</th>
                <th>API Endpoint</th>
                <th>Technology Stack</th>
                <th>Status Code</th>
                <th>Content Length</th>
                <th>CDN</th>
                <th>SPF Record</th>
                <th>DKIM Record</th>
                <th>DMARC Record</th>
                <th>DNSSEC Record</th>
                <th>SSL/TLS Version</th>
                <th>Cert Expiry Date</th>
                <th>SSL/TLS Issuer</th>
                <th>Strict-Transport-Security</th>
                <th>X-Frame-Options</th>
                <th>Content-Security-Policy</th>
                <th>X-XSS-Protection</th>
                <th>Referrer Policy</th>
                <th>Permissions Policy</th>
                <th>Open Ports / Services</th>
              </tr>
              <!-- Second header row for filter dropdowns per column -->
              <tr id="filter-row">
                <th><select id="priority-filter"><option value="">All</option></select></th>
                <th><select id="domain-filter"><option value="">All</option></select></th>
                <th><select id="purpose-filter"><option value="">All</option></select></th>
                <th><select id="resolvers-filter"><option value="">All</option></select></th>
                <th><select id="arecords-filter"><option value="">All</option></select></th>
                <th><select id="ns-filter"><option value="">All</option></select></th>
                <th><select id="mx-filter"><option value="">All</option></select></th>
                <th><select id="dnsstatus-filter"><option value="">All</option></select></th>
                <th><select id="cdnname-filter"><option value="">All</option></select></th>
                <th><select id="cdntype-filter"><option value="">All</option></select></th>
                <th><select id="port-filter"><option value="">All</option></select></th>
                <th><select id="url-filter"><option value="">All</option></select></th>
                <th><select id="redirect-filter"><option value="">All</option></select></th>
                <th><select id="title-filter"><option value="">All</option></select></th>
                <th><select id="webserver-filter"><option value="">All</option></select></th>
                <th><select id="login-filter"><option value="">All</option></select></th>
                <th><select id="api-endpoint-filter"><option value="">All</option></select></th>
                <th><select id="tech-filter"><option value="">All</option></select></th>
                <th><select id="statuscode-filter"><option value="">All</option></select></th>
                <th><select id="contentlength-filter"><option value="">All</option></select></th>
                <th><select id="cdn-filter"><option value="">All</option></select></th>
                <th><select id="spf-filter"><option value="">All</option></select></th>
                <th><select id="dkim-filter"><option value="">All</option></select></th>
                <th><select id="dmarc-filter"><option value="">All</option></select></th>
                <th><select id="dnssec-filter"><option value="">All</option></select></th>
                <th><select id="sslversion-filter"><option value="">All</option></select></th>
                <th><select id="certexpiry-filter"><option value="">All</option></select></th>
                <th><select id="sslissuer-filter"><option value="">All</option></select></th>
                <th><select id="sts-filter"><option value="">All</option></select></th>
                <th><select id="xfo-filter"><option value="">All</option></select></th>
                <th><select id="csp-filter"><option value="">All</option></select></th>
                <th><select id="xss-filter"><option value="">All</option></select></th>
                <th><select id="rp-filter"><option value="">All</option></select></th>
                <th><select id="pp-filter"><option value="">All</option></select></th>
                <th><select id="ports-services-filter"><option value="">All</option></select></th>
              </tr>
            </thead>
            <tbody id="report-table-body"></tbody>
          </table>

          <!-- Container for pagination controls -->
          <div id="paginationControls"></div>
        </div>

        <script>
          // Plugin for displaying labels on bars in charts
          const barLabelPlugin = {
            id: 'barLabelPlugin',
            afterDatasetsDraw(chart, args, options) {
              const { ctx } = chart;
              // Filter visible bar datasets
              const metaSets = chart.getSortedVisibleDatasetMetas().filter(m => m.type === 'bar');
              metaSets.forEach((meta) => {
                meta.data.forEach((element, index) => {
                  const value = meta._parsed[index][meta.vScale.axis];
                  if (value === 0) return;
                  const { x, y } = element.tooltipPosition();
                  ctx.save();
                  ctx.fillStyle = Chart.defaults.color;
                  ctx.font = options.font || '9px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'bottom';
                  ctx.fillText(value, x, y - 2);
                  ctx.restore();
                });
              });
            }
          };
          // Register the custom plugin with Chart.js.
          Chart.register(barLabelPlugin);

          // Declare global variables for charts, table rows, pagination, and risk scores.
          let priorityChart, domainCountChart, statusCodeChart, loginChart, portChart, techChart, certExpiryChart, tlsUsageChart, headersChart, emailSecChart, cdnChart, serviceChart, colleagueChart, cdnTypeChart;
          let allTableRows = [];
          let currentPage = 1;
          let rowsPerPage = 20;
          let riskScores = {};
          let minRiskScore = Infinity;
          let maxRiskScore = -Infinity;
          let riskSortOrder = "desc";

          // --- Begin CSV Export Code ---
          // Function to trigger CSV download from a CSV string
          function downloadCSV(csv, filename) {
            var csvFile = new Blob([csv], { type: "text/csv" });
            var downloadLink = document.createElement("a");
            downloadLink.download = filename;
            downloadLink.href = window.URL.createObjectURL(csvFile);
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
          }

          // Function to extract all table data (using the global array) and generate CSV content
          function exportAllTableRowsToCSV(filename) {
            var csv = [];
            // Get the first header row (from the table header)
            var headerRow = document.querySelectorAll("#report-table thead tr")[0];
            var headers = [];
            headerRow.querySelectorAll("th").forEach(function(th) {
              headers.push('"' + th.innerText.trim().replace(/"/g, '""') + '"');
            });
            csv.push(headers.join(","));

            // Use the global allTableRows array (which holds every row) instead of only the visible rows
            allTableRows.forEach(function(row) {
              var cols = row.querySelectorAll("td");
              var rowData = [];
              cols.forEach(function(td) {
                rowData.push('"' + td.innerText.trim().replace(/"/g, '""') + '"');
              });
              csv.push(rowData.join(","));
            });

            // Trigger the download of the CSV file
            downloadCSV(csv.join("\n"), filename);
          }

          // Attach event listener to the Export CSV button
          document.getElementById("exportCsvButton").addEventListener("click", function() {
            exportAllTableRowsToCSV("report.csv");
          });
          // --- End CSV Export Code ---

          // Theme toggle button event to switch between light and dark themes.
          const toggleButton = document.getElementById("themeToggle");
          toggleButton.addEventListener("click", () => {
            document.body.classList.toggle("dark");
            updateChartTheme();
          });

          // Function to update chart colors based on current theme.
          function updateChartTheme() {
            const newColor = getComputedStyle(document.body).getPropertyValue('--text-color').trim();
            Chart.defaults.color = newColor;
            const charts = [
              priorityChart, domainCountChart, statusCodeChart, loginChart,
              portChart, techChart, certExpiryChart, tlsUsageChart,
              headersChart, emailSecChart, cdnChart, serviceChart, colleagueChart, cdnTypeChart
            ];
            charts.forEach(chart => {
              if (chart) {
                if (chart.options.scales) {
                  if (chart.options.scales.x && chart.options.scales.x.ticks) {
                    chart.options.scales.x.ticks.color = newColor;
                  }
                  if (chart.options.scales.y && chart.options.scales.y.ticks) {
                    chart.options.scales.y.ticks.color = newColor;
                  }
                }
                if (chart.options.plugins && chart.options.plugins.legend && chart.options.plugins.legend.labels) {
                  chart.options.plugins.legend.labels.color = newColor;
                }
                if (chart.options.plugins && chart.options.plugins.title) {
                  chart.options.plugins.title.color = newColor;
                }
                chart.update();
              }
            });
          }

          // Utility function to format array values for table cells.
          function formatCell(arr) {
            return (arr && arr.length) ? arr.join("<br>") : "N/A";
          }

          // Function: computePriority
          // Purpose: Calculate a risk score for a given asset based on various parameters.
          // Also returns an array of debug reasons explaining each part of the score.
          function computePriority({
            purpose,
            url,
            loginFound,
            statusCode,
            sslVersion,
            certExpiry,
            sts,
            xfo,
            csp,
            xss,
            rp,
            pp,
            openPortsCount,
            techCount
          }) {
            let score = 0;
            const reasons = [];

            // Check domain purpose: bonus if employee-oriented.
            if (purpose && purpose.toLowerCase().includes("employee")) {
              score += 1;
              reasons.push("+1 (Potential employee-intended domain found)");
            }

            // Bonus for having a live URL.
            if (url && url !== "N/A") {
              score += 1;
              reasons.push("+1 (Domain has live application)");
            }

            // Bonus if a login interface is detected.
            if (loginFound === "Yes") {
              score += 1;
              reasons.push("+1 (Login interface found on application)");
            }

            // Bonus for a 200 HTTP status code.
            if (statusCode === 200) {
              score += 1;
              reasons.push("+1 (Application has 200 status code)");
            }

            // Evaluate SSL/TLS version; penalize older versions.
            if (sslVersion) {
              const cleanVersion = sslVersion.replace(/\s+/g, '');
              if (/^TLSv(1\.2|1\.3)$/i.test(cleanVersion)) {
                reasons.push("+0 (Version of TLS is latest (1.2 or 1.3))");
              } else if (/^TLSv(1\.0|1\.1)$/i.test(cleanVersion)) {
                score += 1;
                reasons.push("+1 (TLSv1.0 or TLSv1.1)");
              } else if (/^SSLv(1\.0|2\.0|3\.0)$/i.test(cleanVersion)) {
                score += 5;
                reasons.push("+5 (SSLv1/2/3)");
              }
            } else {
              score += 1;
              reasons.push("+1 (no sslVersion reported)");
            }

            // Check certificate expiry; score increases if expiry is soon.
            if (certExpiry && certExpiry !== "N/A") {
              const expiryDate = new Date(certExpiry);
              const now = new Date();
              const diffDays = (expiryDate - now) / (1000 * 60 * 60 * 24);
              if (!isNaN(diffDays)) {
                if (diffDays <= 7) {
                  score += 3;
                  reasons.push("+3 (cert expires in ≤7 days)");
                } else if (diffDays <= 14) {
                  score += 2;
                  reasons.push("+2 (cert expires in ≤14 days)");
                } else if (diffDays <= 30) {
                  score += 1;
                  reasons.push("+1 (cert expires in ≤30 days)");
                }
              }
            }

            // Evaluate presence of critical security headers.
            function missingHeader(val) {
              return !val || val.trim() === "" || val.trim().toLowerCase() === "false";
            }
            if (missingHeader(sts)) {
              score += 1;
              reasons.push("+1 (missing security header - HSTS)");
            }
            if (missingHeader(xfo)) {
              score += 1;
              reasons.push("+1 (missing security header - X-Frame-Options)");
            }
            if (missingHeader(csp)) {
              score += 1;
              reasons.push("+1 (missing security header - CSP)");
            }
            if (missingHeader(xss)) {
              score += 1;
              reasons.push("+1 (missing security header - X-XSS-Protection)");
            }
            if (missingHeader(rp)) {
              score += 1;
              reasons.push("+1 (missing security header - Referrer-Policy)");
            }
            if (missingHeader(pp)) {
              score += 1;
              reasons.push("+1 (missing security header - Permissions-Policy)");
            }

            // Add score based on number of open ports.
            if (openPortsCount && Number.isFinite(openPortsCount)) {
              score += openPortsCount;
              reasons.push(`+${openPortsCount} (count of unique open ports on this domain)`);
            }

            // Add score based on number of technologies detected.
            if (techCount && Number.isFinite(techCount)) {
              score += techCount;
              reasons.push(`+${techCount} (count of unique tech stack found for this application)`);
            }

            return { score, debug: reasons };
          }

          // Function: getDynamicColor
          // Purpose: Calculate a color gradient (from green to red) based on the risk score.
          function getDynamicColor(score, minScore, maxScore) {
            if (maxScore === minScore) {
              return "rgb(46, 204, 113)";
            }
            const fraction = (score - minScore) / (maxScore - minScore);
            const start = { r: 46, g: 204, b: 113 };
            const end   = { r: 231, g: 76, b: 60 };
            const r = Math.round(start.r + fraction * (end.r - start.r));
            const g = Math.round(start.g + fraction * (end.g - start.g));
            const b = Math.round(start.b + fraction * (end.b - start.b));
            return `rgb(${r}, ${g}, ${b})`;
          }

          // Function: buildScoreboard
          // Purpose: Update the score cards with summary metrics.
          function buildScoreboard({ totalSubdomains, liveSubs, totalHttpx, loginFoundCount }) {
            const sb = document.getElementById("scoreboard");
            sb.innerHTML = `
              <div class="score-card">
                <h2>${totalSubdomains}</h2>
                <p>Total Unique Assets</p>
              </div>
              <div class="score-card">
                <h2>${liveSubs}</h2>
                <p>Total Live Assets</p>
              </div>
              <div class="score-card">
                <h2>${totalHttpx}</h2>
                <p>Application Endpoints (Various Ports)</p>
              </div>
              <div class="score-card">
                <h2>${loginFoundCount}</h2>
                <p>Login Interface Found</p>
              </div>
            `;
          }

          // Function: buildCharts
          // Purpose: Create multiple charts using Chart.js based on various data sets.
          function buildCharts({
            statusCount,
            priorityCount,
            portCount,
            techCount,
            totalSubdomains,
            liveSubs,
            endpointsCount
          }) {
            // Build Assets Overview chart.
            const scCanvas = document.getElementById("statusCodeChart");
            const prCanvas = document.getElementById("priorityChart");
            const portCanvas = document.getElementById("portChart");
            const techCanvas = document.getElementById("techChart");

            if (prCanvas) {
              const funnelLabels = ["Total Assets", "Live Assets", "Applications"];
              const funnelValues = [totalSubdomains, liveSubs, endpointsCount];
              if (priorityChart) {
                priorityChart.destroy();
              }
              priorityChart = new Chart(prCanvas, {
                type: "bar",
                data: {
                  labels: funnelLabels,
                  datasets: [{
                    label: "Assets Overview",
                    data: funnelValues,
                    backgroundColor: ["#2980b9", "#8e44ad", "#16a085"]
                  }]
                },
                options: {
                  responsive: true,
                  indexAxis: "x",
                  plugins: {
                    legend: { display: false },
                    title: { display: true, text: "Assets Overview" }
                  },
                  scales: {
                    x: {
                      beginAtZero: true,
                      title: { display: true, text: "Count" }
                    }
                  }
                }
              });
            }

            // Build HTTP Status Codes chart.
            if (scCanvas) {
              const sortedKeys = Object.keys(statusCount).sort((a, b) => +a - +b);
              statusCodeChart = new Chart(scCanvas, {
                type: "bar",
                data: {
                  labels: sortedKeys,
                  datasets: [{
                    label: "HTTP Status Codes",
                    data: sortedKeys.map(l => statusCount[l]),
                    backgroundColor: ["#3498db","#1abc9c","#9b59b6","#f1c40f","#e74c3c","#34495e","#95a5a6"]
                  }]
                },
                options: {
                  responsive: true,
                  plugins: {
                    legend: { display: false },
                    title: { display: true, text: "HTTP Status Codes" }
                  },
                  scales: {
                    y: { beginAtZero: true }
                  }
                }
              });
            }

            // Build Top 10 Open Ports chart.
            if (portCanvas) {
              const sortedPorts = Object.keys(portCount).sort((a, b) => portCount[b] - portCount[a]);
              const top10Ports = sortedPorts.slice(0, 10);
              portChart = new Chart(portCanvas, {
                type: "bar",
                data: {
                  labels: top10Ports,
                  datasets: [{
                    label: "Open Ports",
                    data: top10Ports.map(p => portCount[p]),
                    backgroundColor: "#f39c12"
                  }]
                },
                options: {
                  responsive: true,
                  plugins: {
                    legend: { display: false },
                    title: { display: true, text: "Top 10 Ports" }
                  },
                  scales: {
                    y: { beginAtZero: true }
                  }
                }
              });
            }

            // Build Top 10 Technologies chart.
            if (techCanvas) {
              const sortedTech = Object.keys(techCount).sort((a, b) => techCount[b] - techCount[a]);
              const top10 = sortedTech.slice(0, 10);
              techChart = new Chart(techCanvas, {
                type: "bar",
                data: {
                  labels: top10,
                  datasets: [{
                    label: "Tech Usage (Top 10)",
                    data: top10.map(t => techCount[t]),
                    backgroundColor: "#9b59b6"
                  }]
                },
                options: {
                  responsive: true,
                  indexAxis: "x", // keep it horizontal
                  plugins: {
                    legend: { display: false },
                    title: { display: true, text: "Top 10 Technologies" }
                  },
                  scales: {
                    x: { beginAtZero: true,
                      ticks: {
                        // Rotate labels by -45 or -60 degrees, for example
                        maxRotation: 60,
                        minRotation: 70
                      }
                     }
                  }
                }
              });
            }
          }

          // Function: buildCDNTypeChart
          // Purpose: Create a bar chart to show distribution of CDN types.
          function buildCDNTypeChart(httpxData) {
            const cdnTypeCounts = {};
            httpxData.forEach(record => {
              let cdnType = record.cdn_type;
              if (cdnType && cdnType !== "N/A") {
                cdnType = cdnType.trim();
                cdnTypeCounts[cdnType] = (cdnTypeCounts[cdnType] || 0) + 1;
              }
            });
            const labels = Object.keys(cdnTypeCounts);
            const data = labels.map(l => cdnTypeCounts[l]);
            const ctx = document.getElementById("cdnTypeChart").getContext("2d");
            cdnTypeChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels,
                datasets: [{
                  label: "CDN Type Distribution",
                  data,
                  backgroundColor: "#27ae60"
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: "CDN Type Usage" },
                  legend: { display: false }
                },
                scales: {
                  y: { beginAtZero: true }
                }
              }
            });
          }

          // Function: buildDomainCountChart
          // Purpose: Create a chart showing the top 10 domains based on active URLs.
          function buildDomainCountChart(httpxData) {
          const domainCount = {};
          httpxData.forEach(h => {
            if (h.url && h.url !== "N/A") {
              const domain = (h.input || "").split(":")[0];
              domainCount[domain] = (domainCount[domain] || 0) + 1;
            }
          });

          const sortedDomains = Object.keys(domainCount).sort(
            (a, b) => domainCount[b] - domainCount[a]
          );
          const top10 = sortedDomains.slice(0, 10);
          const data = top10.map(d => domainCount[d]);
          const ctx = document.getElementById("domainCountChart").getContext("2d");

          domainCountChart = new Chart(ctx, {
            type: "bar",
            data: {
              labels: top10,
              datasets: [
                {
                  label: "Top 10 Domains (Active URLs)",
                  data,
                  backgroundColor: "#2980b9"
                }
              ]
            },
            options: {
              responsive: true,
              indexAxis: "x",
              plugins: {
                legend: { display: false },
                title: {
                  display: true,
                  text: "Top 10 Domains by Active URLs"
                }
              },
              scales: {
                x: {
                  beginAtZero: true,
                  ticks: {
                    stepSize: 1,     // Ensure integer increments
                    maxRotation: 100,
                    minRotation: 70
                  }
                }
              }
            }
          });
        }

          // Function: buildLoginBarChart
          // Purpose: Create a bar chart to show the count of endpoints with and without login interfaces.
          function buildLoginBarChart(endpointsCount, loginFoundCount) {
            const canvas = document.getElementById("loginBarChart");
            if (!canvas) return;
            loginChart = new Chart(canvas, {
              type: "bar",
              data: {
                labels: ["Found", "Not Found"],
                datasets: [{
                  data: [loginFoundCount, endpointsCount - loginFoundCount],
                  backgroundColor: ["#e74c3c", "#2ecc71"]
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: "Login Interfaces Identified" },
                  legend: { display: false }
                }
              }
            });
          }

          // Function: buildCertExpiryChart
          // Purpose: Create a chart to show certificate expiry in the next 7, 14, and 30 days.
          function buildCertExpiryChart(secData) {
            let now = new Date();
            let exp7 = 0, exp14 = 0, exp30 = 0;
            secData.forEach(item => {
              const expiryStr = item["Cert Expiry Date"];
              if (expiryStr && expiryStr !== "N/A") {
                let expiryDate = new Date(expiryStr);
                if (!isNaN(expiryDate)) {
                  let diffDays = (expiryDate - now) / (1000 * 60 * 60 * 24);
                  if (diffDays >= 0) {
                    if (diffDays <= 7) { exp7++; }
                    else if (diffDays <= 14) { exp14++; }
                    else if (diffDays <= 30) { exp30++; }
                  }
                }
              }
            });
            const ctx = document.getElementById("certExpiryChart").getContext("2d");
            certExpiryChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels: ["Next 7 Days", "Next 14 Days", "Next 30 Days"],
                datasets: [{
                  label: "Certs Expiring",
                  data: [exp7, exp14, exp30],
                  backgroundColor: ["#e74c3c", "#e67e22", "#3498db"]
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: "Certificate Expiry" },
                  legend: { display: false }
                },
                scales: {
                  y: { beginAtZero: true }
                }
              }
            });
          }

          // Function: buildTLSUsageChart
          // Purpose: Create a chart showing usage of different SSL/TLS versions.
          function buildTLSUsageChart(secData) {
            const tlsCounts = {};
            secData.forEach(item => {
              let ver = item["SSL/TLS Version"];
              ver = ver ? ver.trim() : "Unknown";
              tlsCounts[ver] = (tlsCounts[ver] || 0) + 1;
            });
            const labels = Object.keys(tlsCounts);
            const data = labels.map(l => tlsCounts[l]);
            const ctx = document.getElementById("tlsUsageChart").getContext("2d");
            tlsUsageChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels,
                datasets: [{
                  label: "TLS Version Usage",
                  data,
                  backgroundColor: "#2ecc71"
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: "SSL/TLS Usage" },
                  legend: { display: false }
                },
                scales: {
                  y: { beginAtZero: true }
                }
              }
            });
          }

          // Function: buildHeadersChart
    // Purpose: Create a chart comparing the presence and absence of all key security headers.
    // Headers evaluated: Strict-Transport-Security (HSTS), X-Frame-Options, Content-Security-Policy (CSP),
    // X-XSS-Protection, Referrer-Policy, and Permissions-Policy.
    function buildHeadersChart(httpxData, secMapUrlParam) {
      let hstsPresent = 0, hstsMissing = 0;
      let xfoPresent = 0, xfoMissing = 0;
      let cspPresent = 0, cspMissing = 0;
      let xssPresent = 0, xssMissing = 0;
      let rpPresent = 0, rpMissing = 0;
      let ppPresent = 0, ppMissing = 0;

      httpxData.forEach(record => {
        // Get the domain from the input field (split by ":" in case port is appended)
        const sec = secMapUrlParam[record.url] || {};


        // For each header, trim and verify that its value is not empty, "N/A", or "false"
        const hsts = (sec["Strict-Transport-Security"] || "").trim();
        if (hsts && hsts.toLowerCase() !== "n/a" && hsts.toLowerCase() !== "false") {
          hstsPresent++;
        } else {
          hstsMissing++;
        }

        const xfo = (sec["X-Frame-Options"] || "").trim();
        if (xfo && xfo.toLowerCase() !== "n/a" && xfo.toLowerCase() !== "false") {
          xfoPresent++;
        } else {
          xfoMissing++;
        }

        const csp = (sec["Content-Security-Policy"] || "").trim();
        if (csp && csp.toLowerCase() !== "n/a" && csp.toLowerCase() !== "false") {
          cspPresent++;
        } else {
          cspMissing++;
        }

        const xss = (sec["X-XSS-Protection"] || "").trim();
        if (xss && xss.toLowerCase() !== "n/a" && xss.toLowerCase() !== "false") {
          xssPresent++;
        } else {
          xssMissing++;
        }

        const rp = (sec["Referrer-Policy"] || "").trim();
        if (rp && rp.toLowerCase() !== "n/a" && rp.toLowerCase() !== "false") {
          rpPresent++;
        } else {
          rpMissing++;
        }

        const pp = (sec["Permissions-Policy"] || "").trim();
        if (pp && pp.toLowerCase() !== "n/a" && pp.toLowerCase() !== "false") {
          ppPresent++;
        } else {
          ppMissing++;
        }
      });

      const ctx = document.getElementById("headersChart").getContext("2d");
      headersChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: ["HSTS", "X-Frame-Options", "CSP", "X-XSS-Protection", "Referrer-Policy", "Permissions-Policy"],
          datasets: [
            { label: "Present", data: [hstsPresent, xfoPresent, cspPresent, xssPresent, rpPresent, ppPresent], backgroundColor: "#2ecc71" },
            { label: "Missing", data: [hstsMissing, xfoMissing, cspMissing, xssMissing, rpMissing, ppMissing], backgroundColor: "#e74c3c" }
          ]
        },
        options: {
          responsive: true,
          indexAxis: "x",
          plugins: {
            title: { display: true, text: "Security Headers" },
            tooltip: { mode: "index", intersect: false }
          },
          scales: {
            x: { stacked: true },
            y: { stacked: true, beginAtZero: true }
          }
        }
      });
    }

          // Function: buildEmailSecChart
          // Purpose: Create a chart showing the presence or absence of email security records.
          function buildEmailSecChart(secData) {
            let spfSet = 0, spfMissing = 0;
            let dkimSet = 0, dkimMissing = 0;
            let dmarcSet = 0, dmarcMissing = 0;
            secData.forEach(item => {
              const spf   = item["SPF Record"] || "";
              const dkim  = item["DKIM Record"] || "";
              const dmarc = item["DMARC Record"] || "";
              if (spf.toLowerCase().includes("spf1")) spfSet++; else spfMissing++;
              if (dkim.toLowerCase().includes("dkim1")) dkimSet++; else dkimMissing++;
              if (dmarc.toLowerCase().includes("dmarc1")) dmarcSet++; else dmarcMissing++;
            });
            const ctx = document.getElementById("emailSecChart").getContext("2d");
            emailSecChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels: ["SPF", "DKIM", "DMARC"],
                datasets: [
                  { label: "Present", data: [spfSet, dkimSet, dmarcSet], backgroundColor: "#2ecc71" },
                  { label: "Missing", data: [spfMissing, dkimMissing, dmarcMissing], backgroundColor: "#e74c3c" }
                ]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: "Email Security Records" },
                  tooltip: { mode: "index", intersect: false }
                },
                scales: {
                  x: { stacked: true },
                  y: { stacked: true, beginAtZero: true }
                }
              }
            });
          }

          // Function: buildCDNChart
          // Purpose: Create a chart showing CDN usage statistics.
          function buildCDNChart(httpxData) {
            const cdnCounts = {};
            httpxData.forEach(record => {
              let cdn = record.cdn_name;
              if (cdn && cdn !== "N/A") {
                cdn = cdn.trim();
                cdnCounts[cdn] = (cdnCounts[cdn] || 0) + 1;
              }
            });
            const labels = Object.keys(cdnCounts);
            const data = labels.map(l => cdnCounts[l]);
            const ctx = document.getElementById("cdnChart").getContext("2d");
            cdnChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels,
                datasets: [{
                  label: "CDN Usage",
                  data,
                  backgroundColor: "#3498db"
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: "CDN Usage" },
                  legend: { display: false }
                },
                scales: {
                  y: { beginAtZero: true }
                }
              }
            });
          }

          // Function: buildServiceChart
          // Purpose: Create a chart showing the top 10 open services from port scanning.
          function buildServiceChart(naabuData) {
            const naabuMap = {};
            const serviceCount = {};
            naabuData.forEach(n => {
              const domain = n.host;
              const port = n.port;
              let service = "Unknown";
              // Map well-known ports to their corresponding service names.
              const portServiceDB = {
                "7":"Echo","9":"Discard","13":"Daytime","21":"FTP","22":"SSH","23":"Telnet",
                "25":"SMTP","26":"SMTP","37":"Time","53":"DNS","79":"Finger","80":"HTTP",
                "81":"HTTP","88":"Kerberos","106":"POP3","110":"POP3","111":"RPC","113":"Ident",
                "119":"NNTP","135":"RPC","139":"SMB","143":"IMAP","144":"IMAP","179":"BGP",
                "199":"SMUX","389":"LDAP","427":"SLP","443":"HTTPS","444":"N/A","445":"SMB",
                "465":"SMTPS","513":"rlogin","514":"rsh","515":"Printer","543":"Klogin",
                "544":"Kshell","548":"AFP","554":"RTSP","587":"SMTP Submission","631":"IPP",
                "646":"LDP","873":"rsync","990":"FTPS","993":"IMAPS","995":"POP3S","1433":"MSSQL",
                "1720":"H.323","1723":"PPTP","1755":"Windows Media","1900":"SSDP","2000":"SCCP",
                "2001":"SCCP","2049":"NFS","2121":"FTP-Alt","2717":"MS-SQL","3000":"HTTP-Alt",
                "3128":"Squid","3306":"MySQL","3389":"RDP","3986":"N/A","4899":"N/A","5000":"UPnP",
                "5009":"N/A","5051":"NNTP-Posting","5060":"SIP","5101":"N/A","5190":"ICQ","5357":"WSD",
                "5432":"PostgreSQL","5631":"pcANYWHERE","5666":"NSClient++","5800":"VNC","5900":"VNC",
                "6000":"X11","6001":"X11","6646":"IRC","7070":"RealAudio","8000":"HTTP-Alt",
                "8008":"HTTP-Alt","8009":"AJP13","8080":"HTTP-Alt","8081":"HTTP-Alt","8443":"HTTPS-Alt",
                "8888":"HTTP-Alt","9100":"Printer","9999":"N/A","10000":"N/A","32768":"N/A","49152":"N/A",
                "49153":"N/A","49154":"N/A","49155":"N/A","49156":"N/A","49157":"N/A"
              };
              if (portServiceDB[port]) {
                service = portServiceDB[port];
              }
              if (!naabuMap[domain]) naabuMap[domain] = [];
              naabuMap[domain].push({ port, service });
              serviceCount[service] = (serviceCount[service] || 0) + 1;
            });
            window.naabuMap = naabuMap;
            const ctx = document.getElementById("serviceChart").getContext("2d");
            const sortedServices = Object.keys(serviceCount).sort((a, b) => serviceCount[b] - serviceCount[a]);
            const top10Services = sortedServices.slice(0, 10);
            const data = top10Services.map(service => serviceCount[service]);
            serviceChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels: top10Services,
                datasets: [{
                  label: "Open Services",
                  data,
                  backgroundColor: "#9b59b6"
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { display: false },
                  title: { display: true, text: "Top 10 Services" }
                },
                scales: {
                  y: { beginAtZero: true }
                }
              }
            });
          }

          // Function: buildColleagueChart
          // Purpose: Create a chart comparing endpoints intended for employees versus customers.
          function buildColleagueChart(colleagueData) {
            const countEmployee = colleagueData.filter(x => x.colleague_endpoint === "Yes").length;
            const countCustomer = colleagueData.length - countEmployee;
            const ctx = document.getElementById("colleagueEndpointChart").getContext("2d");
            colleagueChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels: ["Employee Intended", "Customer Intended"],
                datasets: [{
                  label: "Purpose Count",
                  data: [countEmployee, countCustomer],
                  backgroundColor: ["#e74c3c", "#2ecc71"]
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: "Employee vs Customer Intended Endpoints" },
                  legend: { display: false }
                },
                scales: {
                  y: { beginAtZero: true }
                }
              }
            });
          }

          // Global array to store table row elements and additional data.
          let rowDataStore = [];

          // Function: buildTableRows
          // Purpose: Build table rows using combined data from DNS and HTTP results.
          // It also calculates risk scores using computePriority() and applies tooltips.
          function buildTableRows(combinedData, secMapDomain, secMapUrl, loginMap, apiMap, colleagueMap) {
            allTableRows = [];
            rowDataStore = [];
            Object.keys(combinedData).forEach(domain => {
              const { dns, http } = combinedData[domain];
              const dnsResolvers = dns && dns.resolver ? dns.resolver : [];
              const dnsA = dns && dns.a ? dns.a : [];
              const dnsStatus = dns ? dns.status_code : "N/A";
              const domainSec = secMapDomain[domain] || {};
              const spf    = domainSec["SPF Record"] || "N/A";
              const dkim   = domainSec["DKIM Record"] || "N/A";
              const dmarc  = domainSec["DMARC Record"] || "N/A";
              const dnssec = domainSec["DNSSEC Status"] || "N/A";
              const nsRecords = (domainSec["NS Records"] || "N/A").replace(/\n/g, " ");
              const mxRecords = (domainSec["MX Records"] || "N/A").replace(/\n/g, " ");

              let openPortsCount = 0;
              if (window.naabuMap && window.naabuMap[domain]) {
                openPortsCount = window.naabuMap[domain].length;
              }
              if (http && http.length) {
                http.forEach(h => {
                  const urlSec = secMapUrl[h.url] || domainSec;
                  const sslVersion = urlSec["SSL/TLS Version"] || "N/A";
                  const certExpiry = urlSec["Cert Expiry Date"] || "N/A";
                  const sslIssuer  = urlSec["SSL/TLS Issuer"] || "N/A";
                  const stsFlag = (urlSec["Strict-Transport-Security"] || "").trim();
                  const xfoFlag = (urlSec["X-Frame-Options"] || "").trim();
                  const cspFlag = (urlSec["Content-Security-Policy"] || "").trim();
                  const xssFlag = (urlSec["X-XSS-Protection"] || "").trim();
                  const rpFlag  = (urlSec["Referrer-Policy"] || "").trim();
                  const ppFlag  = (urlSec["Permissions-Policy"] || "").trim();
                  const techArr = Array.isArray(h.tech) ? h.tech : [];
                  const sanitizedTech = techArr.map(item => item.replace(/\r?\n|\r/g, " ").trim());
                  const techCount = sanitizedTech.length;

                  // Calculate the risk score and get debugging reasons.
                  const { score, debug } = computePriority({
                    purpose: colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended",
                    url: h.url,
                    loginFound: loginMap[h.url] || "No",
                    statusCode: h.status_code,
                    sslVersion,
                    certExpiry,
                    sts: stsFlag,
                    xfo: xfoFlag,
                    csp: cspFlag,
                    xss: xssFlag,
                    rp:  rpFlag,
                    pp:  ppFlag,
                    openPortsCount,
                    techCount
                  });

                  // Update global min and max risk scores for dynamic coloring.
                  if (score < minRiskScore) minRiskScore = score;
                  if (score > maxRiskScore) maxRiskScore = score;
                  riskScores[domain] = score;
                  rowDataStore.push({ domain, prioScore: score });

                  // Create a new table row and populate its cells.
                  const row = document.createElement("tr");
                  row.innerHTML = `
                    <td><!-- risk score cell; we set text + tooltip below --></td>
                    <td>${domain}</td>
                    <td>${colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended"}</td>
                    <td>${formatCell(dnsResolvers)}</td>
                    <td>${formatCell(dnsA)}</td>
                    <td>${nsRecords}</td>
                    <td>${mxRecords}</td>
                    <td>${dnsStatus}</td>
                    <td>${h.cdn_name || "N/A"}</td>
                    <td>${h.cdn_type || "N/A"}</td>
                    <td>${h.port || "N/A"}</td>
                    <td>${h.url || "N/A"}</td>
                    <td>${h.location || "N/A"}</td>
                    <td>${h.title || "N/A"}</td>
                    <td>${h.webserver || "N/A"}</td>
                    <td>${loginMap[h.url] || "N/A"}</td>
                    <td>${apiMap[domain] || "No"}</td>
                    <td>${sanitizedTech.length ? sanitizedTech.join("<br>") : "N/A"}</td>
                    <td>${(h.status_code !== undefined) ? h.status_code : "N/A"}</td>
                    <td>${(h.content_length !== undefined) ? h.content_length : "N/A"}</td>
                    <td>${(h.cdn !== undefined) ? h.cdn : "N/A"}</td>
                    <td>${spf}</td>
                    <td>${dkim}</td>
                    <td>${dmarc}</td>
                    <td>${dnssec}</td>
                    <td>${sslVersion}</td>
                    <td>${certExpiry}</td>
                    <td>${sslIssuer}</td>
                    <td>${stsFlag ? "True" : "False"}</td>
                    <td>${xfoFlag ? "True" : "False"}</td>
                    <td>${cspFlag ? "True" : "False"}</td>
                    <td>${xssFlag ? "True" : "False"}</td>
                    <td>${rpFlag ? "True" : "False"}</td>
                    <td>${ppFlag ? "True" : "False"}</td>
                    <td>${
                      (window.naabuMap && window.naabuMap[domain])
                      ? window.naabuMap[domain].map(p => `${p.port} (${p.service})`).join("<br>")
                      : "N/A"
                    }</td>
                  `;
                  // Add the new row to the global list.
                  allTableRows.push(row);

                  // Set the risk score cell's text and add a tooltip with debug reasons.
                  const scoreCell = row.getElementsByTagName("td")[0];
                  scoreCell.innerText = score;
                  scoreCell.title = debug.join("\n");
                });
              } else {
                // If there is no HTTP data, create a default row.
                const row = document.createElement("tr");
                row.innerHTML = `
                  <td>N/A</td>
                  <td>${domain}</td>
                  <td>${colleagueMap[domain] === "Yes" ? "Employee Intended" : "Customer Intended"}</td>
                  <td>${formatCell(dnsResolvers)}</td>
                  <td>${formatCell(dnsA)}</td>
                  <td>${nsRecords}</td>
                  <td>${mxRecords}</td>
                  <td>${dnsStatus}</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>${spf}</td>
                  <td>${dkim}</td>
                  <td>${dmarc}</td>
                  <td>${dnssec}</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                  <td>N/A</td>
                `;
                allTableRows.push(row);
              }
            });
          }

          // Function: finalizeColors
          // Purpose: Apply dynamic background colors to risk score cells based on their value.
          function finalizeColors() {
            allTableRows.forEach(row => {
              const cells = row.getElementsByTagName("td");
              const scoreCell = cells[0];
              if (scoreCell.innerText === "N/A") {
                return;
              }
              const prioScore = parseInt(scoreCell.innerText, 10) || 0;
              const color = getDynamicColor(prioScore, minRiskScore, maxRiskScore);
              scoreCell.style.backgroundColor = color;
              scoreCell.style.color = "#fff";
            });
          }

          // Function: getFilteredRows
          // Purpose: Filter table rows based on search query and each column's filter dropdown.
          function getFilteredRows() {
            const query = document.getElementById("searchBox").value.toLowerCase();
            const filters = {
              priority: document.getElementById("priority-filter").value.toLowerCase(),
              domain: document.getElementById("domain-filter").value.toLowerCase(),
              purpose: document.getElementById("purpose-filter").value.toLowerCase(),
              resolvers: document.getElementById("resolvers-filter").value.toLowerCase(),
              arecords: document.getElementById("arecords-filter").value.toLowerCase(),
              ns: document.getElementById("ns-filter").value.toLowerCase(),
              mx: document.getElementById("mx-filter").value.toLowerCase(),
              dnsstatus: document.getElementById("dnsstatus-filter").value.toLowerCase(),
              cdnname: document.getElementById("cdnname-filter").value.toLowerCase(),
              cdntype: document.getElementById("cdntype-filter").value.toLowerCase(),
              port: document.getElementById("port-filter").value.toLowerCase(),
              url: document.getElementById("url-filter").value.toLowerCase(),
              location: document.getElementById("redirect-filter").value.toLowerCase(), // assuming you use "redirect-filter" for location
              title: document.getElementById("title-filter").value.toLowerCase(),
              webserver: document.getElementById("webserver-filter").value.toLowerCase(),
              login: document.getElementById("login-filter").value.toLowerCase(),
              apiEndpoint: document.getElementById("api-endpoint-filter").value.toLowerCase(),
              tech: document.getElementById("tech-filter").value.toLowerCase(),
              statuscode: document.getElementById("statuscode-filter").value.toLowerCase(),
              contentlength: document.getElementById("contentlength-filter").value.toLowerCase(),
              cdn: document.getElementById("cdn-filter").value.toLowerCase(),
              spf: document.getElementById("spf-filter").value.toLowerCase(),
              dkim: document.getElementById("dkim-filter").value.toLowerCase(),
              dmarc: document.getElementById("dmarc-filter").value.toLowerCase(),
              dnssec: document.getElementById("dnssec-filter").value.toLowerCase(),
              sslversion: document.getElementById("sslversion-filter").value.toLowerCase(),
              certexpiry: document.getElementById("certexpiry-filter").value.toLowerCase(),
              sslissuer: document.getElementById("sslissuer-filter").value.toLowerCase(),
              sts: document.getElementById("sts-filter").value.toLowerCase(),
              xfo: document.getElementById("xfo-filter").value.toLowerCase(),
              csp: document.getElementById("csp-filter").value.toLowerCase(),
              xss: document.getElementById("xss-filter").value.toLowerCase(),
              rp: document.getElementById("rp-filter").value.toLowerCase(),
              pp: document.getElementById("pp-filter").value.toLowerCase(),
              portsservices: document.getElementById("ports-services-filter").value.toLowerCase()
            };

            const filtered = allTableRows.filter((row) => {
              const cells = row.getElementsByTagName("td");
              // Use includes() to allow partial matches
              if (filters.priority && !cells[0].innerText.toLowerCase().includes(filters.priority)) return false;
              if (filters.domain && !cells[1].innerText.toLowerCase().includes(filters.domain)) return false;
              if (filters.purpose && !cells[2].innerText.toLowerCase().includes(filters.purpose)) return false;
              if (filters.resolvers && !cells[3].innerText.toLowerCase().includes(filters.resolvers)) return false;
              if (filters.arecords && !cells[4].innerText.toLowerCase().includes(filters.arecords)) return false;
              if (filters.ns && !cells[5].innerText.toLowerCase().includes(filters.ns)) return false;
              if (filters.mx && !cells[6].innerText.toLowerCase().includes(filters.mx)) return false;
              if (filters.dnsstatus && !cells[7].innerText.toLowerCase().includes(filters.dnsstatus)) return false;
              if (filters.cdnname && !cells[8].innerText.toLowerCase().includes(filters.cdnname)) return false;
              if (filters.cdntype && !cells[9].innerText.toLowerCase().includes(filters.cdntype)) return false;
              if (filters.port && !cells[10].innerText.toLowerCase().includes(filters.port)) return false;
              if (filters.url && !cells[11].innerText.toLowerCase().includes(filters.url)) return false;
              if (filters.location && !cells[12].innerText.toLowerCase().includes(filters.location)) return false;
              if (filters.title && !cells[13].innerText.toLowerCase().includes(filters.title)) return false;
              if (filters.webserver && !cells[14].innerText.toLowerCase().includes(filters.webserver)) return false;
              if (filters.login && !cells[15].innerText.toLowerCase().includes(filters.login)) return false;
              if (filters.apiEndpoint && !cells[16].innerText.toLowerCase().includes(filters.apiEndpoint)) return false;
              if (filters.tech && !cells[17].innerText.toLowerCase().includes(filters.tech)) return false;
              if (filters.statuscode && !cells[18].innerText.toLowerCase().includes(filters.statuscode)) return false;
              if (filters.contentlength && !cells[19].innerText.toLowerCase().includes(filters.contentlength)) return false;
              if (filters.cdn && !cells[20].innerText.toLowerCase().includes(filters.cdn)) return false;
              if (filters.spf && !cells[21].innerText.toLowerCase().includes(filters.spf)) return false;
              if (filters.dkim && !cells[22].innerText.toLowerCase().includes(filters.dkim)) return false;
              if (filters.dmarc && !cells[23].innerText.toLowerCase().includes(filters.dmarc)) return false;
              if (filters.dnssec && !cells[24].innerText.toLowerCase().includes(filters.dnssec)) return false;
              if (filters.sslversion && !cells[25].innerText.toLowerCase().includes(filters.sslversion)) return false;
              if (filters.certexpiry && !cells[26].innerText.toLowerCase().includes(filters.certexpiry)) return false;
              if (filters.sslissuer && !cells[27].innerText.toLowerCase().includes(filters.sslissuer)) return false;
              if (filters.sts && !cells[28].innerText.toLowerCase().includes(filters.sts)) return false;
              if (filters.xfo && !cells[29].innerText.toLowerCase().includes(filters.xfo)) return false;
              if (filters.csp && !cells[30].innerText.toLowerCase().includes(filters.csp)) return false;
              if (filters.xss && !cells[31].innerText.toLowerCase().includes(filters.xss)) return false;
              if (filters.rp && !cells[32].innerText.toLowerCase().includes(filters.rp)) return false;
              if (filters.pp && !cells[33].innerText.toLowerCase().includes(filters.pp)) return false;
              if (filters.portsservices && !cells[34].innerText.toLowerCase().includes(filters.portsservices)) return false;
              if (query && !row.innerText.toLowerCase().includes(query)) return false;
              return true;
            });

            // Sort rows by risk score (assumed to be in the first cell)
            filtered.sort((a, b) => {
              const scoreA = parseInt(a.cells[0].innerText) || 0;
              const scoreB = parseInt(b.cells[0].innerText) || 0;
              return riskSortOrder === "asc" ? scoreA - scoreB : scoreB - scoreA;
            });

            return filtered;
          }

          // Function: renderTable
          // Purpose: Render the filtered rows in the table body with pagination.
          function renderTable(filteredRows) {
            const tBody = document.getElementById("report-table-body");
            tBody.innerHTML = "";
            let startIndex = 0;
            let endIndex = filteredRows.length;
            if (rowsPerPage !== "all" && rowsPerPage !== Infinity) {
              startIndex = (currentPage - 1) * rowsPerPage;
              endIndex = startIndex + rowsPerPage;
            }
            const rowsToShow = filteredRows.slice(startIndex, endIndex);
            rowsToShow.forEach(row => tBody.appendChild(row));
            renderPaginationControls(filteredRows.length);
          }

          // Function: renderPaginationControls
          // Purpose: Create and display pagination controls below the table.
          function renderPaginationControls(totalRows) {
            const paginationDiv = document.getElementById("paginationControls");
            paginationDiv.innerHTML = "";
            if (rowsPerPage === "all" || rowsPerPage === Infinity) return;
            const totalPages = Math.ceil(totalRows / rowsPerPage);
            const pageInfo = document.createElement("span");
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            paginationDiv.appendChild(pageInfo);

            const prevBtn = document.createElement("button");
            prevBtn.textContent = "Prev";
            prevBtn.disabled = currentPage === 1;
            prevBtn.addEventListener("click", () => {
              if (currentPage > 1) {
                currentPage--;
                renderTable(getFilteredRows());
              }
            });
            paginationDiv.appendChild(prevBtn);

            const nextBtn = document.createElement("button");
            nextBtn.textContent = "Next";
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.addEventListener("click", () => {
              if (currentPage < totalPages) {
                currentPage++;
                renderTable(getFilteredRows());
              }
            });
            paginationDiv.appendChild(nextBtn);
          }

          // Function: onFilterChange
          // Purpose: Reset pagination and re-render table rows when a filter changes.
          function onFilterChange() {
            currentPage = 1;
            renderTable(getFilteredRows());
          }

          // Function: updateRowsPerPage
          // Purpose: Update the global rowsPerPage based on the dropdown and re-render the table.
          function updateRowsPerPage() {
            const select = document.getElementById("rowsPerPageSelect");
            const value = select.value;
            if (value === "all") rowsPerPage = Infinity;
            else rowsPerPage = parseInt(value, 10);
            currentPage = 1;
            renderTable(getFilteredRows());
          }

          // Function: populateColumnFilters
          // Purpose: Populate filter dropdowns for each table column with unique values.
          function populateColumnFilters() {
            const uniqueCols = Array.from({ length: 35 }, () => new Set());
            allTableRows.forEach((row) => {
              const cells = row.getElementsByTagName("td");
              for (let col = 0; col < 35; col++) {
                uniqueCols[col].add(cells[col].innerText.trim());
              }
            });
            function fillSelectOptions(selectId, values) {
              const select = document.getElementById(selectId);
              const existing = select.querySelectorAll("option:not([value=''])");
              existing.forEach((opt) => opt.remove());
              if (selectId === "priority-filter") {
                values = values.filter(v => !isNaN(v)).sort((a, b) => b - a);
              } else {
                values.sort();
              }
              values.forEach((val) => {
                if (val.toLowerCase() === "asc" || val.toLowerCase() === "desc") {
                  return;
                }
                const option = document.createElement("option");
                option.value = val;
                option.textContent = val;
                select.appendChild(option);
              });
            }
            // Mapping filter dropdowns to uniqueCols array
      fillSelectOptions("priority-filter",   [...uniqueCols[0]]);
      fillSelectOptions("domain-filter",     [...uniqueCols[1]]);
      fillSelectOptions("purpose-filter",    [...uniqueCols[2]]);
      fillSelectOptions("resolvers-filter",  [...uniqueCols[3]]);
      fillSelectOptions("arecords-filter",   [...uniqueCols[4]]);
      fillSelectOptions("ns-filter",         [...uniqueCols[5]]);
      fillSelectOptions("mx-filter",         [...uniqueCols[6]]);
      fillSelectOptions("dnsstatus-filter",  [...uniqueCols[7]]);
      fillSelectOptions("cdnname-filter",    [...uniqueCols[8]]);
      fillSelectOptions("cdntype-filter",    [...uniqueCols[9]]);
      fillSelectOptions("port-filter",       [...uniqueCols[10]]);
      fillSelectOptions("url-filter",        [...uniqueCols[11]]);
      fillSelectOptions("redirect-filter",   [...uniqueCols[12]]);
      fillSelectOptions("title-filter",      [...uniqueCols[13]]);
      fillSelectOptions("webserver-filter",  [...uniqueCols[14]]);
      fillSelectOptions("login-filter",      [...uniqueCols[15]]);
      fillSelectOptions("api-endpoint-filter", [...uniqueCols[16]]);
      fillSelectOptions("tech-filter",       [...uniqueCols[17]]);
      fillSelectOptions("statuscode-filter", [...uniqueCols[18]]);
      fillSelectOptions("contentlength-filter", [...uniqueCols[19]]);
      fillSelectOptions("cdn-filter",        [...uniqueCols[20]]);
      fillSelectOptions("spf-filter",        [...uniqueCols[21]]);
      fillSelectOptions("dkim-filter",       [...uniqueCols[22]]);
      fillSelectOptions("dmarc-filter",      [...uniqueCols[23]]);
      fillSelectOptions("dnssec-filter",     [...uniqueCols[24]]);
      fillSelectOptions("sslversion-filter", [...uniqueCols[25]]);
      fillSelectOptions("certexpiry-filter", [...uniqueCols[26]]);
      fillSelectOptions("sslissuer-filter",  [...uniqueCols[27]]);
      fillSelectOptions("sts-filter",        [...uniqueCols[28]]);
      fillSelectOptions("xfo-filter",        [...uniqueCols[29]]);
      fillSelectOptions("csp-filter",        [...uniqueCols[30]]);
      fillSelectOptions("xss-filter",        [...uniqueCols[31]]);
      fillSelectOptions("rp-filter",         [...uniqueCols[32]]);
      fillSelectOptions("pp-filter",         [...uniqueCols[33]]);
      fillSelectOptions("ports-services-filter", [...uniqueCols[34]]);
    }

          // Attach event listeners to the search box, rows per page dropdown, and risk sort toggle.
          document.getElementById("searchBox").addEventListener("input", onFilterChange);
          document.getElementById("rowsPerPageSelect").addEventListener("change", updateRowsPerPage);
          document.getElementById("riskSortToggle").addEventListener("click", function() {
            riskSortOrder = (riskSortOrder === "asc") ? "desc" : "asc";
            this.textContent = (riskSortOrder === "asc") ? "▲" : "▼";
            renderTable(getFilteredRows());
          });

          // Async function: loadData
          // Purpose: Load JSON data from various files, build charts, table rows, and render the HTML report.
          async function loadData() {
            try {
